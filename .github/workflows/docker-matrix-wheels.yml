name: Matrix-build-wheels

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main
      - 'releases/**'
  release:
    types: 
      - published
      - released

jobs:
  prepare_build:
#    name: Get fhempy version
    runs-on: ubuntu-latest
    outputs:
      fhempyV: ${{steps.split_fhempyV.outputs.result}}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Split fhempy Version
        id: split_fhempyV
        run: |
          echo "result=$(grep '^fhempy' requirements.txt | cut -d '=' -f3)" >> $GITHUB_OUTPUT      
 
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v2

      - name: Build builder stage
        id: build_base_cross
        uses: docker/build-push-action@v3.2.0
        with:
          context: .
          file: Dockerfile.wheels
          platforms: linux/amd64,linux/arm/v6,linux/arm/v7
          push: false
          target: base
          cache-to: type=gha,mode=max,scope=base_stage_cross
          cache-from: |
            type=gha,scope=base_stage_cross


  prepare_matrix:
#   name:  Find fhempy modules 
    needs: prepare_build
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{steps.getModules.outputs.matrix}}

    steps:
      - uses: actions/checkout@v3
        with:
          repository: 'fhempy/fhempy'
          ref: 'v${{ needs.prepare_build.outputs.fhempyV }}'

      - name: Get module name and prepare matrix
        id: getModules
        working-directory: FHEM/bindings/python/fhempy/lib
        run: |
          JSON='{ "include":[] }'
          # Gather requirements from fhempy module
          readarray -t REQS < <(cat ../../../../../requirements.txt | jq --raw-input -c)
          for r in "${REQS[@]}"
          do
                JSON=$(echo $JSON | jq -c --argjson REQUIREMENTS $r --arg PACKAGES "cargo rustc" --arg M "fhempy" '.include += [{"module": $M, "requirements": [$REQUIREMENTS], "PKGS" : $PACKAGES} ]')
          done
          readarray -t MODS < <(find ./ -type f -name manifest.json -exec sh -c 'dirname {}' \;  | sed 's|^./||')
          #printf '%s\n' "${MODS[@]}"
          for i in "${MODS[@]}"
          do
              REQS=$(jq -cr 'select(.requirements != []).requirements' ./"$i"/manifest.json)
              if [[ -z $REQS ]]; then
                continue
              fi
              ADD_PKGS=""
              # skip problematic modules until solution found
              if [[ "$i" =~ "object_detection" ]]; then 
                continue 
              fi
              if [[ "$i" =~ ^(eq3bt|gfprobt|ble_reset|blue_connect|object_detection)$ ]]; then 
                ADD_PKGS="cmake ninja-build"
              elif [[ "$i" =~ ^(seatconnect|skodaconnect|miio|xiaomi_gateway3|xiaomi_gateway3_device|pyit600|esphome)$ ]]; then 
                ADD_PKGS="rustc cargo"
              fi
              JSON=$(echo $JSON | jq -c --argjson REQUIREMENTS $REQS --arg PACKAGES "$ADD_PKGS" --arg M "$i" '.include += [{"module": $M, "requirements": $REQUIREMENTS, "PKGS" : $PACKAGES} ]')
          done
          #echo $JSON
          echo "matrix=$JSON" >> $GITHUB_OUTPUT
        shell: bash

  buildwWeels:
    runs-on: ubuntu-latest
    needs: [prepare_build, prepare_matrix]
    strategy:
      matrix:
        ${{fromJson(needs.prepare_matrix.outputs.matrix)}}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: check variables
        run: |
          echo '${{ toJSON(matrix) }}'
          echo '${{ matrix.module }}'

      - name: write requirement for mod from matrix input
        run: |
          echo '${{toJSON(matrix.requirements)}}'  | jq --raw-output -e '.[]' > ./requirements_mod.txt
          cat ./requirements_mod.txt

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Run Docker on tmpfs
        uses: sidey79/docker-on-tmpfs@main
        with:
          tmpfs_size: 6
          swap_size: 4
          swap_location: '/mnt/swapfile'

      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v2
      #  with:
      #   buildkitd-flags: --debug


      - name: Build wheels 
        uses: docker/build-push-action@v3.2.0
        with:
          context: .
          file: Dockerfile.wheels
          platforms: linux/amd64,linux/arm/v6,linux/arm/v7
          push: false
          target: export-stage
          outputs: type=local,dest=./wheelhouse
          cache-to: type=gha,scope=export_stage_cross-${{ matrix.module }}_${{ hashFiles('./requirements_mod.txt') }}
          cache-from: |
            type=gha,scope=base_stage_cross
            type=gha,scope=export_stage_cross-${{ matrix.module }}_${{ hashFiles('./requirements_mod.txt') }}
          build-args: |
            PKGS=${{ matrix.PKGS }}

      - name: Build wheels again if failed wo gha cache armv7 only
        if: failure()
        uses: docker/build-push-action@v3.2.0
        with:
          context: .
          file: Dockerfile.wheels
          platforms: linux/arm/v7
          push: false
          target: export-stage
          outputs: type=local,dest=./wheelhouse
          cache-to: type=gha,scope=export_stage_cross-${{ matrix.module }}_${{ hashFiles('./requirements_mod.txt') }}
          cache-from: type=gha,scope=base_stage_cross
          build-args: |
            PKGS=${{ matrix.PKGS }}

      - name: upload wheels as artifact for module ${{matrix.module}}
        uses: actions/upload-artifact@v3
        with: 
          name: ${{matrix.module}}
          path: |
            ./wheelhouse/*/wheels
            ./wheelhouse/*/requirements.txt
          retention-days: 7


  buildfhempy:
    needs: [prepare_build, buildwWeels]
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      # This is used to complete the identity challenge
      # with sigstore/fulcio when running outside of PRs.
      id-token: write
    env:
      # Use docker.io for Docker Hub if empty
      REGISTRY: ghcr.io
      # github.repository as <account>/<repo>
      IMAGE_NAME: ${{ github.repository }}
    outputs:
      imageid: ${{ steps.docker_build_runtime_cross.outputs.imageid }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Find image String
        id: extract_image
        run: |
           echo "image_name=$(grep -m 1 '^FROM' Dockerfile | cut -d ' ' -f2 | cut -d ':' -f1)" >> $GITHUB_OUTPUT
           echo "image_version=$(grep -m 1 '^FROM' Dockerfile | cut -d ' ' -f2 | cut -d ':' -f2)" >> $GITHUB_OUTPUT
      
      - name: Update docs
        if: ${{ github.event_name == 'release' }}
        run: |
            sed -e "s/{FHEMPY_VERSION}/${{ needs.prepare_build.outputs.fhempyV }}/" -e "s/{PYTHON_VERSION}/${{ steps.extract_image.outputs.image_version}}/" -e "s/{DEBIAN_RELEASE}/buster/" -e s/{IMAGE_TAG}/${{ github.ref_name }}/ < README.tmpl > README.md

      # Install the cosign tool except on PR
      # https://github.com/sigstore/cosign-installer
      - name: Install cosign
        if: github.event_name == 'release'
        uses: sigstore/cosign-installer@v2.8.1
        with:
          cosign-release: 'v1.9.0'

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: fetch our artifacts
        uses: actions/download-artifact@v3
        with:
          path: ./wheelhouse/

      - name: list files in wheel Cache before running a build
        run: |
          du -a ./wheelhouse/

      - name: Build image and run integrationtests (amd64)
        id: build_and_run_integrationtests
        uses: ./.github/actions/integrationtest
        with:
           PLATTFORM: linux/amd64
           FHEMPY_VERSION: ${{ needs.prepare_build.outputs.fhempyV }}

      # Login against a Docker registry if it is a release
      # https://github.com/docker/login-action
      - name: Log into registry ${{ env.REGISTRY }}
        #if: github.event_name == 'release'
        uses: docker/login-action@v2.0.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v4.1.1
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          flavor: |
             latest= ${{ fromJSON('["auto", "false"]')[github.event.release.prerelease == 1] }}
          tags: |
            type=ref,enable=true,priority=600,prefix=pr-,suffix=,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}},enable=${{ github.event.release.prerelease == 0 }}
            type=ref,event=branch
            type=ref,event=pr


      # Build and push Docker image with Buildx (don't push if it is not a release)
      # https://github.com/docker/build-push-action
      - name: Build base image for all plattforms
        id: build_base_cross
        uses: docker/build-push-action@v3.2.0
        with:
          context: .
          platforms: linux/amd64,linux/arm/v6,linux/arm/v7
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: FHEMPY_V=${{ needs.prepare_build.outputs.fhempyV }}
          target: base

      #- name: list files in wheel Cache
      #  run: |
      #    du -a ./wheelhouse

      - name: Build and push Docker image for all plattforms
        uses: docker/build-push-action@v3.2.0
        id: docker_build_runtime_cross
        with:
          context: .
          platforms: linux/arm/v7
          push: true # ${{ github.event_name == 'release' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: | 
            type=gha,scope=verify_runtime_linux/amd64
            type=gha,scope=publish_runtime_cross
          cache-to: type=gha,mode=max,scope=publish_runtime_cross
          build-args: FHEMPY_V=${{ needs.prepare_build.outputs.fhempyV }}
          target: runtime

      - name: show image details
        run: | 
          echo ${{ steps.docker_build_runtime_cross.outputs.imageid }}
          echo ${{ steps.docker_build_runtime_cross.outputs.digest }}
      # Sign the resulting Docker image digest except on PRs.
      # This will only write to the public Rekor transparency log when the Docker
      # repository is public to avoid leaking data.  If you would like to publish
      # transparency data even for private images, pass --force to cosign below.
      # https://github.com/sigstore/cosign
      - name: Sign the published Docker image
        if: ${{ github.event_name == 'release' }}
        env:
          COSIGN_EXPERIMENTAL: "true"
        # This step uses the identity token to provision an ephemeral certificate
        # against the sigstore community Fulcio instance.
        run: echo "${{ steps.meta.outputs.tags }}" | xargs -I {} cosign sign {}@${{ steps.docker_build_runtime_cross.outputs.digest }}
      
      - name: git commit README.md 
        id: commit
        if: ${{ github.event_name == 'release' }}
        run: |
          git config --global user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git commit -m "README.md: Update Versions" -a && echo "::set-output name=status::true" || true
      
      - name: Push back to protected branch (main)
        uses: CasperWA/push-protected@v2
        if: ${{ github.event_name == 'release' }}
        with:
          token: ${{ secrets.BOT_PUSH_TOKEN }}
          branch: main
          #unprotect_reviews: true

  run-container:
    # Containers must run in Linux based operating systems
    runs-on: ubuntu-latest
    
    needs: [buildfhempy,prepare_build]
    # Service containers to run with `container-job`
    services:
      fhem: 
        image: ghcr.io/fhem/fhem/fhem-minimal-docker:3-bullseye
        ports:
          - 8083:8083
        volumes:
          - ${{ github.workspace }}/opt/fhem:/opt/fhem
        options: >-
          -e CPAN_PKGS="Protocol::WebSocket"
         
      fhempy:
        image:  ghcr.io/fhem/fhempy-docker@${{ needs.buildfhempy.outputs.imageid }}

    steps:
      - uses: actions/checkout@v3
        with:
          repository: 'fhempy/fhempy'
          ref: 'v${{ needs.prepare_build.outputs.fhempyV }}'
          path: fhempy


      - name: copy perl Modules to fhem volume directory
        run: |
          sudo cp ./fhempy/FHEM/*.pm ${{ github.workspace }}/opt/fhem/FHEM

      - name: install fhemcl tool
        run: |
          wget -O fhemcl.sh https://raw.githubusercontent.com/heinz-otto/fhemcl/master/fhemcl.sh
          chmod +x fhemcl.sh

      
      - name: test googleweather
        run: |
          echo "::group::Install Modules"
          echo -e "reload 10_fhempy" | ./fhemcl.sh http://localhost:8083
          echo -e "reload 10_BindingsIo" | ./fhemcl.sh http://localhost:8083
          echo "::endgroup::"

          echo "::group::Define fhempy"          
          echo -e "define fhempy_peer_IP BindingsIo fhempy:15733 fhempy" | ./fhemcl.sh http://localhost:8083
          echo -e "list  fhempy_peer_IP" | ./fhemcl.sh http://localhost:8083
          sleep 7
          echo "::endgroup::"

          echo "::group::Define google_weather"          
          echo -e "define my_weather fhempy google_weather frankfurt" | ./fhemcl.sh http://localhost:8083
          sleep 10
          echo -e "list my_weather" | ./fhemcl.sh http://localhost:8083
          echo "::endgroup::"
